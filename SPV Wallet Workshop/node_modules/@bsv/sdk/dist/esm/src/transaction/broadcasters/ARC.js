import { defaultHttpClient } from "../http/DefaultHttpClient.js";
import Random from "../../primitives/Random.js";
import { toHex } from "../../primitives/utils.js";
function defaultDeploymentId() {
    return `ts-sdk-${toHex(Random(16))}`;
}
/**
 * Represents an ARC transaction broadcaster.
 */
export default class ARC {
    URL;
    apiKey;
    deploymentId;
    callbackUrl;
    callbackToken;
    headers;
    httpClient;
    constructor(URL, config) {
        this.URL = URL;
        if (typeof config === 'string') {
            this.apiKey = config;
            this.httpClient = defaultHttpClient();
            this.deploymentId = defaultDeploymentId();
            this.callbackToken = undefined;
            this.callbackUrl = undefined;
        }
        else {
            const { apiKey, deploymentId, httpClient, callbackToken, callbackUrl, headers } = config ?? {};
            this.apiKey = apiKey;
            this.httpClient = httpClient ?? defaultHttpClient();
            this.deploymentId = deploymentId ?? defaultDeploymentId();
            this.callbackToken = callbackToken;
            this.callbackUrl = callbackUrl;
            this.headers = headers;
        }
    }
    /**
     * Broadcasts a transaction via ARC.
     *
     * @param {Transaction} tx - The transaction to be broadcasted.
     * @returns {Promise<BroadcastResponse | BroadcastFailure>} A promise that resolves to either a success or failure response.
     */
    async broadcast(tx) {
        let rawTx;
        try {
            rawTx = tx.toHexEF();
        }
        catch (error) {
            if (error.message === 'All inputs must have source transactions when serializing to EF format') {
                rawTx = tx.toHex();
            }
            else {
                throw error;
            }
        }
        const requestOptions = {
            method: 'POST',
            headers: this.requestHeaders(),
            data: { rawTx }
        };
        try {
            const response = await this.httpClient.request(`${this.URL}/v1/tx`, requestOptions);
            if (response.ok) {
                const { txid, extraInfo, txStatus } = response.data;
                return {
                    status: 'success',
                    txid: txid,
                    message: `${txStatus} ${extraInfo}`
                };
            }
            else {
                const st = typeof response.status;
                const r = {
                    status: 'error',
                    code: st === 'number' || st === 'string' ? response.status.toString() : 'ERR_UNKNOWN',
                    description: 'Unknown error'
                };
                let d = response.data;
                if (typeof d === 'string') {
                    try {
                        d = JSON.parse(response.data);
                    }
                    catch { }
                }
                if (typeof d === 'object') {
                    r.more = d;
                    if (typeof d.txid === 'string') {
                        r.txid = d.txid;
                    }
                    if (typeof d.detail === 'string') {
                        r.description = d.detail;
                    }
                }
                return r;
            }
        }
        catch (error) {
            return {
                status: 'error',
                code: '500',
                description: typeof error.message === 'string'
                    ? error.message
                    : 'Internal Server Error'
            };
        }
    }
    requestHeaders() {
        const headers = {
            'Content-Type': 'application/json',
            'XDeployment-ID': this.deploymentId,
        };
        if (this.apiKey) {
            headers['Authorization'] = `Bearer ${this.apiKey}`;
        }
        if (this.callbackUrl) {
            headers['X-CallbackUrl'] = this.callbackUrl;
        }
        if (this.callbackToken) {
            headers['X-CallbackToken'] = this.callbackToken;
        }
        if (!!this.headers) {
            for (const key in this.headers) {
                headers[key] = this.headers[key];
            }
        }
        return headers;
    }
}
//# sourceMappingURL=ARC.js.map